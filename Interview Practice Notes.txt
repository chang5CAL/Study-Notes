KMP: When looking for most matching strings in a nested for loop, move the 

Anagrams: To find if an object is an anagram, simply put all characters in to a 26(27 for space) array, and
sort it. Repeat to the compared object, then check if they are the same.
Alternatively, only do that to one, and subtract one from the array, returning false if the value at the area
is 0 pre-calculation, and true if you are finished and all elements are 0.
Of course, always make sure they're the same length.
Another way is to put all characters in a vector and then sort it.

Note: Copy by hand if answer is not found in one hour.

This anagram problem frustrates me. I get what to do, take everything, sort as vector, compare vectors,
if it's the same (Which, if they're anagrams, they will be), store that and if not done already, store the
initial string.

Also of note, don't use Lintcode's IDE, use your own, because bugtesting is a major pain when you can't
cout anything.

Note: Looks like there's not much problem with simply throwing an "In case of edge case (Like a "" string) if
statement", if there aren't too many edge cases that have this problem. If there are, you may need to
reevaluate your algorithm.

Looks like there's actually a substring function (And if not, not hard to write one), which would have 
helped my append string function (Just make something a substring). There's no guarenteed way to avoid 
analyzing everything (Barring a ""), so it will always be O(nm).

Remove Element: Simple enough, just run a for loop through the array, check if it's the element, remove it
if so, move up one if not. The biggest catch is if you forget it adjusts as you go, so you'll go 1, remove 1,
2, which was 3, and not check the actual second element.

Sub Array Sum: Looks like a nested for loop will do the job. Not terribly efficient, so I'll want to look up
the anctual answer.

My solution is basically a for loop that started at the beginning, then a second one that went from there to the
end. If at any point, the sum of parts equal 0, return the two points, else move the first one up and
move the second until the end, and so on. This tests every adjacent combination.