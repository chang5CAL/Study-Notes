KMP: When looking for most matching strings in a nested for loop, move the 

Anagrams: To find if an object is an anagram, simply put all characters in to a 26(27 for space) array, and
sort it. Repeat to the compared object, then check if they are the same.
Alternatively, only do that to one, and subtract one from the array, returning false if the value at the area
is 0 pre-calculation, and true if you are finished and all elements are 0.
Of course, always make sure they're the same length.
Another way is to put all characters in a vector and then sort it.

Note: Copy by hand if answer is not found in one hour.

This anagram problem frustrates me. I get what to do, take everything, sort as vector, compare vectors,
if it's the same (Which, if they're anagrams, they will be), store that and if not done already, store the
initial string.

Also of note, don't use Lintcode's IDE, use your own, because bugtesting is a major pain when you can't
cout anything.

Note: Looks like there's not much problem with simply throwing an "In case of edge case (Like a "" string) if
statement", if there aren't too many edge cases that have this problem. If there are, you may need to
reevaluate your algorithm.

Looks like there's actually a substring function (And if not, not hard to write one), which would have 
helped my append string function (Just make something a substring). There's no guarenteed way to avoid 
analyzing everything (Barring a ""), so it will always be O(nm).

Remove Element: Simple enough, just run a for loop through the array, check if it's the element, remove it
if so, move up one if not. The biggest catch is if you forget it adjusts as you go, so you'll go 1, remove 1,
2, which was 3, and not check the actual second element.

Sub Array Sum: Looks like a nested for loop will do the job. Not terribly efficient, so I'll want to look up
the anctual answer.

My solution is basically a for loop that started at the beginning, then a second one that went from there to the
end. If at any point, the sum of parts equal 0, return the two points, else move the first one up and
move the second until the end, and so on. This tests every adjacent combination.

Remove Duplicates from sorted: If it's not already sorted, sort it! Because that makes this way easier.
Start at 1, so you can just look backwards one, if it exists. If it doesn't, then you have a single vector
and can't backtrack, so you can't have duplicates. Done. If it does, then you can look back, and if it
matches, just delete the value, otherwise, move forward by one. Same as remove element.

Merge Sorted Arrays: The give away is kind of in the name. It's basically the second half of a mergesort,
assembling two different sorted arrays, so all you need to do is measure via merge sort.

Multiply all excluding self: All I need to do is make a temp array/vector, and fill it up with multiplication
from all other values except the current position, and then return the finished array. There might be a shortcut
if you just make it check for two 0's, or at least just one 0, where it will ignore every value (Just autofill
with 0) except for the 0, or just make an entire vector of 0's if there's two 0's. Don't forget to make it 
push_back a 1 to start with, so it has something to work with!

First Missing Positive: First, sort the vector. Then make a for loop, starting at the first value, going up
until the i value doesn't match the vector's value at that position. Then just return i. Remove all but one
non-unique value. Oh, here's the problem: this problem treats 0 oddly. 0 can not exist for all this problem
cares.

Sum of 3 Closest: Need 3 for loops. Basically, first stands on the 0th position, second on 1, third on 2.
Move third until it hits the last one, then do the second to the second to last, and third to third to last,
finding the sum of all and keeping track of the nearest (Via comparing abs(target-top) vs. abs(target-current)),
UNLESS the comparison is 0.
Assumes there is at least 3 elements.

2 Sum: Shouldn't be too hard. Have two for loops, one starts at 0, the other at i+1 (i being the first index),
and keep going until it finds a match. Once it does, put both index(+1) in a vector and return that vector.

Sum of 3: Do the same as above, but store the 3 if it's a 0, only. And go through the whole thing every time.